# Introduction to CPU profiling

CPU profiling is not the only profiling possible, but it is the most important. [Linux profiling with performance counters](https://perfwiki.github.io/main/) explains how performance measurement can be done. It is done using `perf` command. To collect the profiles on per-process, per-thread, per-cpu basis. We need an illustrative program to do some measurements. [bottlenecks.cpp](bottlenecks.cpp) is a simple program generated by [ChatGPT](https://chatgpt.com/) for this purpose. To compile the program

```
g++ -O2 -g -ggdb -fno-inline -std=c++17 bottlenecks.cpp -o bottlenecks
```

Now you can run it under `perf`

```sh
$ sudo perf record -g -F 99 -- ./bottlenecks

Starting CPU-bound section...
Primes computed: 2262
Starting memory-bound section...
Matrix multiplication done for size 300x300
Starting I/O-bound section...
File written with 1000000 lines.
Total time: 0.170326 s
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.024 MB perf.data (18 samples) ]
```

This produces a file `perf.data` in the current directory as shown above. There are multiple ways to analyze the output. Simples is

```sh
$ sudo perf report -g --stdio

# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 18  of event 'cycles:P'
# Event count (approx.): 749271655
#
# Children      Self  Command      Shared Object         Symbol                                                                                                                                 >
# ........  ........  ...........  ....................  .......................................................................................................................................>
#
    66.45%    20.32%  bottlenecks  bottlenecks           [.] random_matrix_multiply(int)
            |
            |--46.13%--random_matrix_multiply(int)
            |
             --20.32%--0
                       random_matrix_multiply(int)

    66.45%     0.00%  bottlenecks  [unknown]             [.] 0000000000000000
            |
            ---0
               random_matrix_multiply(int)

    46.13%    46.13%  bottlenecks  bottlenecks           [.] std::vector<std::vector<double, std::allocator<double> >, std::allocator<std::vector<double, std::allocator<double> > > >::operator>
            |
            ---0
               random_matrix_multiply(int)

    33.43%     0.00%  bottlenecks  bottlenecks           [.] write_file(long)
            |
            ---write_file(long)
...
```

## Flamegraphs with perf

This is how I use it in my work day in and day out. [Brendan Gregg](https://www.brendangregg.com/index.html) created this magical tool that helps us visualize profiling results. He as also documented [Linux performance observability](https://www.brendangregg.com/linuxperf.html) extensively. It posprocesses `perf.data` to produce a `SVG` (Scalable Vector Graphics) file that can be loaded in web-browser enabling us to search/dissect it interactively. He has published his work [here](https://github.com/brendangregg/FlameGraph). Here is how we can use it. First download the scripts from Brendan's github repo.

```sh
wget https://raw.githubusercontent.com/brendangregg/FlameGraph/refs/heads/master/stackcollapse-perf.pl
wget https://raw.githubusercontent.com/brendangregg/FlameGraph/refs/heads/master/flamegraph.pl
```

Once you have these two scripts, we can run in on our `perf.data` file.

```sh
sudo perf script > bottlenecks.perf
perl stackcollapse-perf.pl bottlenecks.perf > bottlenecks.folded
perl flamegraph.pl bottlenecks.folded > bottlenecks.svg
```
All this we need to do is point the browser at [bottlenecks.svg](bottlenecks.svg). You can delete `bottlenecks.perf` and `bottlenecks.folded`.

## Multi-threaded version of bottlenecks

Flamegraph is equally useful for looking at the performance of multi-threaded programs. MT version of our demo [bottlenecks-mt.cpp](bottlenecks-mt.cpp) can be analyzed as follows:
```sh
$ g++ -O2 -g -ggdb -fno-inline -std=c++17 bottlenecks-mt.cpp -o bottlenecks-mt

$ sudo perf record -g -F 99 -- ./bottlenecks-mt
Using 16 threads.

[CPU-bound]
Primes found: 2262

[Memory-bound]
Matrix multiplication done for size 300x300

[I/O-bound]
File written with 200000 lines.

Total time: 0.0847577 s
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 2.294 MB perf.data (3998 samples) ]
```

Notice that the samples are significantly higher - given that they need to be collected for each execution unit. Post processing steps are identical.
```sh
perf script > bottlenecks-mt.perf
perl stackcollapse-perf.pl bottlenecks.perf > bottlenecks-mt.folded
perl flamegraph.pl bottlenecks.folded > bottlenecks-mt.svg
```
The [result](bottlenecks-mt.svg) is interesting.

## Running perf tools on Windows/Mac
Just connect to your `sysprog` instance.
```sh
$ sudo multipass shell sysprog
Welcome to Ubuntu 24.04.3 LTS (GNU/Linux 6.8.0-85-generic aarch64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/pro

 System information as of Mon Oct 20 10:18:25 IST 2025

  System load:             0.0
  Usage of /:              22.6% of 8.65GB
  Memory usage:            5%
  Swap usage:              0%
  Processes:               129
  Users logged in:         0
  IPv4 address for enp0s1: 192.168.2.2
  IPv6 address for enp0s1: fdb0:2327:1cc6:cbf2:5054:ff:feaf:db7


Expanded Security Maintenance for Applications is not enabled.

14 updates can be applied immediately.
To see these additional updates run: apt list --upgradable

Enable ESM Apps to receive additional future security updates.
See https://ubuntu.com/esm or run: sudo pro status


To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

ubuntu@sysprog:~$
```
Test that perf works
```sh
ubuntu@sysprog:~$ sudo perf record -a -g sleep 10

[ perf record: Woken up 4 times to write data ]
[ perf record: Captured and wrote 1.196 MB perf.data (8611 samples) ]
ubuntu@sysprog:~$ sudo perf report -g --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 8K of event 'cpu-clock:ppp'
# Event count (approx.): 2152750000
#
# Children      Self  Command          Shared Object          Symbol
# ........  ........  ...............  .....................  ....................................
#
    99.63%     0.00%  swapper          [kernel.kallsyms]      [k] cpu_startup_entry
            |
            ---cpu_startup_entry
               |
                --99.56%--do_idle
                          |
                           --98.37%--cpuidle_idle_call
                                     |
                                      --11.68%--default_idle_call
...
```
## References

1. [Linux Observability tools](https://www.brendangregg.com/linuxperf.html)
1. [perf: Linux profiling with performance counters](https://perfwiki.github.io/main/)
1. [Flamegraph](https://github.com/brendangregg/FlameGraph)
